{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"About Getting Started Example of Math Formula \\[\\mathbb{P}=\\mathbb{NP}\\] Example of Click Box Item that is ready Item not ready Example of Content Box C++ // Example of C++ Code int main () { return 0; } python # Example of python Code if __name__ == \"__main__\": pass Example of Pop-out Notice Important Notice All the changes","title":"About"},{"location":"index.html#about","text":"","title":"About"},{"location":"index.html#getting-started","text":"","title":"Getting Started"},{"location":"index.html#example-of-math-formula","text":"\\[\\mathbb{P}=\\mathbb{NP}\\]","title":"Example of Math Formula"},{"location":"index.html#example-of-click-box","text":"Item that is ready Item not ready","title":"Example of Click Box"},{"location":"index.html#example-of-content-box","text":"C++ // Example of C++ Code int main () { return 0; } python # Example of python Code if __name__ == \"__main__\": pass","title":"Example of Content Box"},{"location":"index.html#example-of-pop-out-notice","text":"Important Notice All the changes","title":"Example of Pop-out Notice"},{"location":"Logic_Synthesis/index.html","text":"About Logic Synthesis Chapter 1 Introduction of Boolean Algebra Section 1: Boolean Axioms Chapter 2 Logic Modeling Section 1: Truth Table Section 2: Binary Decision Diagram Section 3: Satisfiability Chapter 3 Area Optimization Section 1: Rewrite Section 2: Refactor Section 3: Resubstitution Chapter 4 Delay Optimization Section 1: Balance Section 2: Gate Duplication Section 3: Buffer Insertion Chapter 5 Runtime Speedup Section 1: Boolean Filter Section 2: Window Extraction","title":"About"},{"location":"Logic_Synthesis/index.html#about","text":"Logic Synthesis Chapter 1","title":"About"},{"location":"Logic_Synthesis/index.html#introduction-of-boolean-algebra","text":"Section 1: Boolean Axioms Chapter 2","title":"Introduction of Boolean Algebra"},{"location":"Logic_Synthesis/index.html#logic-modeling","text":"Section 1: Truth Table Section 2: Binary Decision Diagram Section 3: Satisfiability Chapter 3","title":"Logic Modeling"},{"location":"Logic_Synthesis/index.html#area-optimization","text":"Section 1: Rewrite Section 2: Refactor Section 3: Resubstitution Chapter 4","title":"Area Optimization"},{"location":"Logic_Synthesis/index.html#delay-optimization","text":"Section 1: Balance Section 2: Gate Duplication Section 3: Buffer Insertion Chapter 5","title":"Delay Optimization"},{"location":"Logic_Synthesis/index.html#runtime-speedup","text":"Section 1: Boolean Filter Section 2: Window Extraction","title":"Runtime Speedup"},{"location":"Logic_Synthesis/boolean.html","text":"Introduction of Boolean Algebra Boolean Axioms Delay Optimization: \\(x(yz) = (xy)z\\) Area Optimization: \\(x(y+z) = xy+xz\\) Trivial Optimization: \\(xx=x\\) , \\(xx'=0\\)","title":"Introduction of Boolean Algebra"},{"location":"Logic_Synthesis/boolean.html#introduction-of-boolean-algebra","text":"","title":"Introduction of Boolean Algebra"},{"location":"Logic_Synthesis/boolean.html#boolean-axioms","text":"Delay Optimization: \\(x(yz) = (xy)z\\) Area Optimization: \\(x(y+z) = xy+xz\\) Trivial Optimization: \\(xx=x\\) , \\(xx'=0\\)","title":"Boolean Axioms"},{"location":"Logic_Synthesis/ABC/ABC_Commands.html","text":"","title":"ABC Commands"},{"location":"Personal/linux.html","text":"My Linux Configurations In this year, I tried to deploy my linux OS on ubuntu 20.04 LTS. Below is the procedure, commands and scripts. Advantage of Ubuntu 20.04 LTS Comparing to 18.04 LTS: Step 0: Install ssh and sshd : By default, you should have ssh already in the environment. To install sshd , the server, run: sudo apt-get install openssh-server Then start the server: service sshd start Then we modify the file in /etc/ssh/sshd_config , and change the following settings: PubkeyAuthentication yes PasswordAuthentication no Next, put the public key of your PC to the ~/.ssh/authorized_keys so that we can log in without password. Then we run ssh and login remotely. frp Server: nohup ./frps -c frps.ini Client: nohup ./frpc -c frpc.ini Step 1: Install zsh and oh-my-zsh : First we install the dependencies, including zsh . sudo apt-get install curl wget git zsh Then we install oh-my-zsh from github: sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" And then change the theme of oh my zsh git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k And in ~/.zshrc , set powerlevel10k/powerlevel10k . zsh plugins auto suggestions git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions Add the plugins zsh-autosuggestions in ~/.zshrc Step 2: Proxy Auto Config sudo apt-get install python3-pip sudo apt-get install shadowsocks-libev Then edit the file /etc/shadowsocks-libev/config.json then: sudo systemctl start shadowsocks-libev-local@config.service sudo systemctl enable shadowsocks-libev-local@config.service to check the status: netstat -tlnp proxy export https_proxy=\"socks5://127.0.0.1:1080\" Nginx PAC file generation sudo apt install nginx sudo pip install genpac sudo genpac --pac-proxy \"SOCKS5 127.0.0.1:1080\" --gfwlist-proxy=\"SOCKS5 127.0.0.1:1080\" --gfwlist-url=https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt --output=\"/var/www/html/autoproxy.pac\" set GNOME global settings gsettings set org.gnome.system.proxy mode auto gsettings set org.gnome.system.proxy autoconfig-url 'http://localhost/autoproxy.pac' To disable gsettings set org.gnome.system.proxy mode none","title":"My Linux Configurations"},{"location":"Personal/linux.html#my-linux-configurations","text":"In this year, I tried to deploy my linux OS on ubuntu 20.04 LTS. Below is the procedure, commands and scripts. Advantage of Ubuntu 20.04 LTS Comparing to 18.04 LTS:","title":"My Linux Configurations"},{"location":"Personal/linux.html#step-0-install-ssh-and-sshd","text":"By default, you should have ssh already in the environment. To install sshd , the server, run: sudo apt-get install openssh-server Then start the server: service sshd start Then we modify the file in /etc/ssh/sshd_config , and change the following settings: PubkeyAuthentication yes PasswordAuthentication no Next, put the public key of your PC to the ~/.ssh/authorized_keys so that we can log in without password. Then we run ssh and login remotely.","title":"Step 0: Install ssh and sshd:"},{"location":"Personal/linux.html#frp","text":"Server: nohup ./frps -c frps.ini Client: nohup ./frpc -c frpc.ini","title":"frp"},{"location":"Personal/linux.html#step-1-install-zsh-and-oh-my-zsh","text":"First we install the dependencies, including zsh . sudo apt-get install curl wget git zsh Then we install oh-my-zsh from github: sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" And then change the theme of oh my zsh git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k And in ~/.zshrc , set powerlevel10k/powerlevel10k .","title":"Step 1: Install zsh and oh-my-zsh:"},{"location":"Personal/linux.html#zsh-plugins","text":"","title":"zsh plugins"},{"location":"Personal/linux.html#auto-suggestions","text":"git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions Add the plugins zsh-autosuggestions in ~/.zshrc","title":"auto suggestions"},{"location":"Personal/linux.html#step-2-proxy-auto-config","text":"sudo apt-get install python3-pip sudo apt-get install shadowsocks-libev Then edit the file /etc/shadowsocks-libev/config.json then: sudo systemctl start shadowsocks-libev-local@config.service sudo systemctl enable shadowsocks-libev-local@config.service to check the status: netstat -tlnp","title":"Step 2: Proxy Auto Config"},{"location":"Personal/linux.html#proxy","text":"export https_proxy=\"socks5://127.0.0.1:1080\"","title":"proxy"},{"location":"Personal/linux.html#nginx-pac-file-generation","text":"sudo apt install nginx sudo pip install genpac sudo genpac --pac-proxy \"SOCKS5 127.0.0.1:1080\" --gfwlist-proxy=\"SOCKS5 127.0.0.1:1080\" --gfwlist-url=https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt --output=\"/var/www/html/autoproxy.pac\"","title":"Nginx PAC file generation"},{"location":"Personal/linux.html#set-gnome-global-settings","text":"gsettings set org.gnome.system.proxy mode auto gsettings set org.gnome.system.proxy autoconfig-url 'http://localhost/autoproxy.pac' To disable gsettings set org.gnome.system.proxy mode none","title":"set GNOME global settings"},{"location":"Personal/research_summary.html","text":"Logic Synthesis Research Summary Timeline & Overview Declaration : useful work : not work 2019 Oct Read ABC base Code: understand the data structures inside ABC, e.g. Abc_Ntk_t , Abc_Obj_t , Abc_Cut_t , Vec_Ptr_t , ... Read BLIF , AIGER format: understand how to use tools to convert between different format: e.g. aig2aag , aag2aig Read EPFL benchmarks: understand the contest of best depth and best size . Write a python BLIF parser 2019 Dec Read graphviz : visualize the logic network based on dot and graphviz , can be then converted to post script format. Write Idea 1 . 2020 Mar Help Zhou Zhuoer Write Idea 2 2020 Jun Help Mao Xingyun Write Idea 3 Read SAT based algorithms, RL algorithms: understand recent efforts to apply machine learning algorithms on improving logic synthesis. Read Yosys and EPFL LS Library : parse verilog files and convert to BLIF files. learn EPFL toolkits, including Alice , Mockturtles and try ALSO which is implemented based on EPFL toolkit. Moreover, visit Open Source EDA tools on OpenRoad . 2020 Jul Read ABC advanced commands dc2 and dch . understand 3 basic operations in logic synthesis are rewrite , refactor and resub Write Idea 4 2020 Oct Read Stochastic Algorithms studied by Fiser , including paritial network , Cartesian Genetic Programming , and Random Permuation . Read LEKO and LEKU from J. Cong , which studies the optimality of logic synthesis. Write ABC Rewrite Pre-literature Search Report, which concludes the logic synthesis as a combinatorial optimization problem, which includes local optimizations and global scheduling. Write Visualization Engine for Capstone project, which visualize the logic rewriting process. 2020 Dec Write Idea 5 Read GNN algorithms 2021 Jan Read verification algorithms. understand how to combine simulation and SAT solver and the relationship between logic synthesis and verifications. Read Fanout Optimization Related Works. including TechMap Algorithms , Gate Duplciation , Buffer Insersion , and Rewiring algorithms. Help Huang Shen 2021 Apr Write Idea 6 2021 Jun Problems, Solutions, & Results Problem 1: Fanout Optimization with strict limit (2019.10 - 2020.03) Develop an algorithm to fix fanout overload in LUT network. The fanout limit for emerging circuit is low but current designs have large fanuot nodes, e.g. dec_depth_2018 's maximum fanout number is 64. Keywords: fanout Solution: convert local LUT network \\(N\\) to AIG \\(N'\\) . fix fanout number using buffer or duplication, get \\(N''\\) map to LUTs \\(N'''\\) Results: our method works on the network with small fanouts local network (MFFC) is usually big, sometimes the local extracted network is equivalent to the whole network. ABC mapper will run redundancy removal and revert our operations to fix fanout overload. Problem 2: Fanout Optimization with soft limit (2020.03 - 2020.04) Develop an algorithm to reduce the fanout delay on the critical path. The delay model is given by \\(Delay(G) = A+B\\times fanout(G))\\) . Keywords: fanout, delay optimization Solution: MFS (2020.03) Modify the target function in ABC mfs , find the new divisors to represent a function and optimize the fanout distribution upon nodes. On the other hand, if the area is optimized during mfs , new nodes are added to duplicate the high fanout nodes. mfs pseudocode for node in network: for n_old in node.fanin: n_new <= TryResub(node, n_old) if fanout(n_old) < fanout (n_new): Update(node): n_old => n_new duplication pseudocode _ntk <= MFS(ntk) area_saved <= node_num(ntk)-node_num(_ntk) while area_saved > 0: Duplicate(highest_fanout_node) area_saved-- Result: 18% TFCP reduction on average (on selected EPFL benchmarks, whose network is large enough and has room of improvement.) all of the reduction are caused by the area optimization and the duplication, but not our \"modified\" mfs method. Update: critical path update & larger window size (2020.11) Improve the duplication and mfs performance by updating the critical path after each network rewriting. Manually set the hyperparameters of ABC mfs function and increase the default window size of mfs while area optimization and rewiring. Result 28% (previous +10%) TFP reduction on average. Update: refine rewiring criteria & enable area increasement (2021.04) write the project ReFO and provide more options to the user. optimize the rewiring criteria and avoid making negative fanout changes to the network. Result 35% Delay Optimization ( \\(1+0.2\\times fanout(G)\\) model) without Area increase on average. Problem 3: Improve ABC rewrite performance on area optimization (2021.03 - present) The target of ABC rewrite is to reduce the AND nodes number in the AIG without increasing the level of it. There are several aspects that could be potentially optimized (sub-problems): 1. the combination of rewrite , refactor , resub . 2. the node traversal order and rewrite task scheduling of rewrite function. 3. the local 4-feasible cut rewrite machanism. Note that the 3 problems are listed from the upper level to the lower level. keywords: AIG, area optimization Solution: optimize the combination of rewrite , refactor , resub -- Priority Scheduler (2020.08) keywords: priority scheduler Add a filter the operation procedure and make decision for each node if it should be operated based on the evaluation result. priority scheduler pseudocode seq <= compress2rs sequence for op in seq: next_op <= op.next for node in network: gain <= EvalGain(op, node)-EvalGain(next_op, node) if gain > 0: Run(op, node) EvalGain(op, node) means try operation op (one of the rewrite , refactor , rewrite ) on the node , and return the gain (node number reduction for area optimization) can get from this operation. We only run operation on this node if and only if the current operation is better than the later operation. Result 0.1% area improvement on the EPFL benchmark hard to decide which solution is better (although the target does not consider level, ABC rewrite is able to reduce the delay. Sometime our area is better but delay is worse). Solution: the node traversal order and rewrite task scheduling of rewrite function (2020.03 - 2020.08) keywords: simulated annealing Modify the traversal order and rewrite update decision making by including a simulated annealing process into the rewrite engine. simulated annealing pseudocode T <= T_start # initial temperature while T > T_end: node <= RandomPick(network) op <= RandomPick({rewrite,refactor,resub}) gain <= Eval(op, node) with exp(gain/T) as probability: Run(op, node) T <= CoolDown(T) Result converge to the same result no matter how we set the parameters. the probability of getting \"coincidence\" that \"accidently\" negatively change the neighbour nodes in the correct way is extremely low (the probability is equal to evolutionary algorithms like CGP). do not have enough theoretical proofs of our negative moves. Update: ALTERSEQ (2020.05) keywords: alternately In order to increase the probability of getting useful negative rewriting and make more changes to the current state, we alternately run Negative rewriting and Positive rewriting, which is similar to the Espresso expand and reduce operations. ALTERNEQ pseudocode iter <= num_iterations # set the number of iterations for iter times: # negative rewrite nodes <= RandomPick(network, num_nodes) NegRewrite(nodes) # positive rewrite PosRewrite(network) Reuslt found some useful negative rewrite on one trail but the probability is still low. the runtime is long due to the large iteration numbers (we have to make sure the value of num_nodes*num_iterations is about the number of nodes we have) Update: QUICKSEQ (2020.06) keywords: quick To accelarate previous method, we develop a faster script. QUICKSEQ pseudocode iter <= num_iterations # set the number of iterations for iter times: # negative rewrite nodes <= RandomPick(network, num_nodes) modified_nodes <= NegRewrite(nodes) # positive rewrite PosRewrite(modified_nodes) The difference is that, instead of doing the positive rewrite on the whole network, we only run it on the area we have changed in this iteration. Result The run-time is significantly reduced. The nodes are not properly marked and the result is different from ALTERSEQ.","title":"Logic Synthesis Research Summary"},{"location":"Personal/research_summary.html#logic-synthesis-research-summary","text":"","title":"Logic Synthesis Research Summary"},{"location":"Personal/research_summary.html#timeline-overview","text":"Declaration : useful work : not work","title":"Timeline &amp; Overview"},{"location":"Personal/research_summary.html#2019-oct","text":"Read ABC base Code: understand the data structures inside ABC, e.g. Abc_Ntk_t , Abc_Obj_t , Abc_Cut_t , Vec_Ptr_t , ... Read BLIF , AIGER format: understand how to use tools to convert between different format: e.g. aig2aag , aag2aig Read EPFL benchmarks: understand the contest of best depth and best size . Write a python BLIF parser","title":"2019 Oct"},{"location":"Personal/research_summary.html#2019-dec","text":"Read graphviz : visualize the logic network based on dot and graphviz , can be then converted to post script format. Write Idea 1 .","title":"2019 Dec"},{"location":"Personal/research_summary.html#2020-mar","text":"Help Zhou Zhuoer Write Idea 2","title":"2020 Mar"},{"location":"Personal/research_summary.html#2020-jun","text":"Help Mao Xingyun Write Idea 3 Read SAT based algorithms, RL algorithms: understand recent efforts to apply machine learning algorithms on improving logic synthesis. Read Yosys and EPFL LS Library : parse verilog files and convert to BLIF files. learn EPFL toolkits, including Alice , Mockturtles and try ALSO which is implemented based on EPFL toolkit. Moreover, visit Open Source EDA tools on OpenRoad .","title":"2020 Jun"},{"location":"Personal/research_summary.html#2020-jul","text":"Read ABC advanced commands dc2 and dch . understand 3 basic operations in logic synthesis are rewrite , refactor and resub Write Idea 4","title":"2020 Jul"},{"location":"Personal/research_summary.html#2020-oct","text":"Read Stochastic Algorithms studied by Fiser , including paritial network , Cartesian Genetic Programming , and Random Permuation . Read LEKO and LEKU from J. Cong , which studies the optimality of logic synthesis. Write ABC Rewrite Pre-literature Search Report, which concludes the logic synthesis as a combinatorial optimization problem, which includes local optimizations and global scheduling. Write Visualization Engine for Capstone project, which visualize the logic rewriting process.","title":"2020 Oct"},{"location":"Personal/research_summary.html#2020-dec","text":"Write Idea 5 Read GNN algorithms","title":"2020 Dec"},{"location":"Personal/research_summary.html#2021-jan","text":"Read verification algorithms. understand how to combine simulation and SAT solver and the relationship between logic synthesis and verifications. Read Fanout Optimization Related Works. including TechMap Algorithms , Gate Duplciation , Buffer Insersion , and Rewiring algorithms. Help Huang Shen","title":"2021 Jan"},{"location":"Personal/research_summary.html#2021-apr","text":"Write Idea 6","title":"2021 Apr"},{"location":"Personal/research_summary.html#2021-jun","text":"","title":"2021 Jun"},{"location":"Personal/research_summary.html#problems-solutions-results","text":"Problem 1: Fanout Optimization with strict limit (2019.10 - 2020.03) Develop an algorithm to fix fanout overload in LUT network. The fanout limit for emerging circuit is low but current designs have large fanuot nodes, e.g. dec_depth_2018 's maximum fanout number is 64. Keywords: fanout Solution: convert local LUT network \\(N\\) to AIG \\(N'\\) . fix fanout number using buffer or duplication, get \\(N''\\) map to LUTs \\(N'''\\) Results: our method works on the network with small fanouts local network (MFFC) is usually big, sometimes the local extracted network is equivalent to the whole network. ABC mapper will run redundancy removal and revert our operations to fix fanout overload. Problem 2: Fanout Optimization with soft limit (2020.03 - 2020.04) Develop an algorithm to reduce the fanout delay on the critical path. The delay model is given by \\(Delay(G) = A+B\\times fanout(G))\\) . Keywords: fanout, delay optimization Solution: MFS (2020.03) Modify the target function in ABC mfs , find the new divisors to represent a function and optimize the fanout distribution upon nodes. On the other hand, if the area is optimized during mfs , new nodes are added to duplicate the high fanout nodes. mfs pseudocode for node in network: for n_old in node.fanin: n_new <= TryResub(node, n_old) if fanout(n_old) < fanout (n_new): Update(node): n_old => n_new duplication pseudocode _ntk <= MFS(ntk) area_saved <= node_num(ntk)-node_num(_ntk) while area_saved > 0: Duplicate(highest_fanout_node) area_saved-- Result: 18% TFCP reduction on average (on selected EPFL benchmarks, whose network is large enough and has room of improvement.) all of the reduction are caused by the area optimization and the duplication, but not our \"modified\" mfs method. Update: critical path update & larger window size (2020.11) Improve the duplication and mfs performance by updating the critical path after each network rewriting. Manually set the hyperparameters of ABC mfs function and increase the default window size of mfs while area optimization and rewiring. Result 28% (previous +10%) TFP reduction on average. Update: refine rewiring criteria & enable area increasement (2021.04) write the project ReFO and provide more options to the user. optimize the rewiring criteria and avoid making negative fanout changes to the network. Result 35% Delay Optimization ( \\(1+0.2\\times fanout(G)\\) model) without Area increase on average. Problem 3: Improve ABC rewrite performance on area optimization (2021.03 - present) The target of ABC rewrite is to reduce the AND nodes number in the AIG without increasing the level of it. There are several aspects that could be potentially optimized (sub-problems): 1. the combination of rewrite , refactor , resub . 2. the node traversal order and rewrite task scheduling of rewrite function. 3. the local 4-feasible cut rewrite machanism. Note that the 3 problems are listed from the upper level to the lower level. keywords: AIG, area optimization Solution: optimize the combination of rewrite , refactor , resub -- Priority Scheduler (2020.08) keywords: priority scheduler Add a filter the operation procedure and make decision for each node if it should be operated based on the evaluation result. priority scheduler pseudocode seq <= compress2rs sequence for op in seq: next_op <= op.next for node in network: gain <= EvalGain(op, node)-EvalGain(next_op, node) if gain > 0: Run(op, node) EvalGain(op, node) means try operation op (one of the rewrite , refactor , rewrite ) on the node , and return the gain (node number reduction for area optimization) can get from this operation. We only run operation on this node if and only if the current operation is better than the later operation. Result 0.1% area improvement on the EPFL benchmark hard to decide which solution is better (although the target does not consider level, ABC rewrite is able to reduce the delay. Sometime our area is better but delay is worse). Solution: the node traversal order and rewrite task scheduling of rewrite function (2020.03 - 2020.08) keywords: simulated annealing Modify the traversal order and rewrite update decision making by including a simulated annealing process into the rewrite engine. simulated annealing pseudocode T <= T_start # initial temperature while T > T_end: node <= RandomPick(network) op <= RandomPick({rewrite,refactor,resub}) gain <= Eval(op, node) with exp(gain/T) as probability: Run(op, node) T <= CoolDown(T) Result converge to the same result no matter how we set the parameters. the probability of getting \"coincidence\" that \"accidently\" negatively change the neighbour nodes in the correct way is extremely low (the probability is equal to evolutionary algorithms like CGP). do not have enough theoretical proofs of our negative moves. Update: ALTERSEQ (2020.05) keywords: alternately In order to increase the probability of getting useful negative rewriting and make more changes to the current state, we alternately run Negative rewriting and Positive rewriting, which is similar to the Espresso expand and reduce operations. ALTERNEQ pseudocode iter <= num_iterations # set the number of iterations for iter times: # negative rewrite nodes <= RandomPick(network, num_nodes) NegRewrite(nodes) # positive rewrite PosRewrite(network) Reuslt found some useful negative rewrite on one trail but the probability is still low. the runtime is long due to the large iteration numbers (we have to make sure the value of num_nodes*num_iterations is about the number of nodes we have) Update: QUICKSEQ (2020.06) keywords: quick To accelarate previous method, we develop a faster script. QUICKSEQ pseudocode iter <= num_iterations # set the number of iterations for iter times: # negative rewrite nodes <= RandomPick(network, num_nodes) modified_nodes <= NegRewrite(nodes) # positive rewrite PosRewrite(modified_nodes) The difference is that, instead of doing the positive rewrite on the whole network, we only run it on the area we have changed in this iteration. Result The run-time is significantly reduced. The nodes are not properly marked and the result is different from ALTERSEQ.","title":"Problems, Solutions, &amp; Results"}]}